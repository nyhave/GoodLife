<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0a0e17">
  <title>ORB Trading System</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #0a0e17;
      --bg-secondary: #111827;
      --bg-card: #1a1f2e;
      --bg-card-hover: #232a3b;
      --border: #2a3142;
      --text-primary: #e5e7eb;
      --text-secondary: #9ca3af;
      --text-muted: #6b7280;
      --accent-blue: #3b82f6;
      --accent-green: #10b981;
      --accent-red: #ef4444;
      --accent-yellow: #f59e0b;
      --accent-purple: #8b5cf6;
      --accent-cyan: #06b6d4;
      --shadow: 0 4px 6px -1px rgba(0,0,0,0.3);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }
    .mono { font-family: 'JetBrains Mono', monospace; }

    /* Top Navigation */
    .top-nav {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      height: 56px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 100;
    }
    .nav-logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      font-size: 18px;
      letter-spacing: -0.5px;
    }
    .nav-logo .logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 700;
    }
    .nav-tabs {
      display: flex;
      gap: 4px;
    }
    .nav-tab {
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
      transition: all 0.15s;
      border: none;
      background: none;
    }
    .nav-tab:hover { color: var(--text-primary); background: var(--bg-card); }
    .nav-tab.active { color: var(--accent-blue); background: rgba(59,130,246,0.1); }
    .nav-status {
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 13px;
    }
    .cache-clear-btn {
      padding: 4px 10px;
      font-size: 11px;
      font-family: 'JetBrains Mono', monospace;
      border: 1px solid rgba(239,68,68,0.3);
      border-radius: 6px;
      background: rgba(239,68,68,0.08);
      color: var(--accent-red);
      cursor: pointer;
      transition: all 0.15s;
    }
    .cache-clear-btn:hover {
      background: rgba(239,68,68,0.18);
      border-color: rgba(239,68,68,0.5);
    }
    .market-status {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent-green);
      animation: pulse 2s infinite;
    }
    .status-dot.closed { background: var(--accent-red); animation: none; }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Layout */
    .app-container { padding: 16px; max-width: 1600px; margin: 0 auto; }
    .grid-2 { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 16px; align-items: start; }
    .grid-3 { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 16px; align-items: start; }
    .grid-4 { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 16px; align-items: start; }
    .grid-2-1 { display: grid; grid-template-columns: minmax(0, 2fr) minmax(0, 1fr); gap: 16px; align-items: start; }
    .grid-1-2 { display: grid; grid-template-columns: minmax(0, 1fr) minmax(0, 2fr); gap: 16px; align-items: start; }
    .mb-16 { margin-bottom: 16px; }

    /* Cards */
    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
    }
    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .card-title {
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
    }
    .card-badge {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: 500;
    }

    /* Stat boxes */
    .stat-box {
      text-align: center;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: 8px;
      border: 1px solid var(--border);
      min-width: 0;
      overflow: hidden;
    }
    .stat-value {
      font-size: 22px;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
      line-height: 1.2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .stat-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 4px;
    }
    .stat-value.positive { color: var(--accent-green); }
    .stat-value.negative { color: var(--accent-red); }
    .stat-value.neutral { color: var(--accent-yellow); }

    /* Chart container */
    .chart-container {
      width: 100%;
      height: 350px;
      border-radius: 8px;
      overflow: hidden;
      background: var(--bg-secondary);
    }
    .chart-container.tall { height: 450px; }
    .chart-container.short { height: 250px; }
    .chart-container canvas { width: 100% !important; }

    /* Opening Range Overlay */
    .or-info {
      display: flex;
      gap: 16px;
      align-items: center;
      padding: 10px 16px;
      background: rgba(59,130,246,0.08);
      border: 1px solid rgba(59,130,246,0.2);
      border-radius: 8px;
      font-size: 13px;
    }
    .or-info span { color: var(--text-secondary); }
    .or-info strong { color: var(--text-primary); font-family: 'JetBrains Mono', monospace; }

    /* Trade log table */
    .trade-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    .trade-table th {
      text-align: left;
      padding: 8px 10px;
      color: var(--text-muted);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 1px solid var(--border);
      font-size: 11px;
    }
    .trade-table td {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(42,49,66,0.5);
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
    }
    .trade-table tr:hover td { background: var(--bg-card-hover); }
    .trade-table .pnl-positive { color: var(--accent-green); }
    .trade-table .pnl-negative { color: var(--accent-red); }
    .dir-long {
      color: var(--accent-green);
      background: rgba(16,185,129,0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
      font-weight: 600;
    }
    .dir-short {
      color: var(--accent-red);
      background: rgba(239,68,68,0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
      font-weight: 600;
    }

    /* Sentiment gauge */
    .sentiment-gauge {
      position: relative;
      width: 200px;
      height: 110px;
      margin: 0 auto;
    }
    .gauge-bg {
      width: 200px;
      height: 100px;
      border-radius: 100px 100px 0 0;
      background: linear-gradient(90deg, var(--accent-red), var(--accent-yellow), var(--accent-green));
      overflow: hidden;
      position: relative;
    }
    .gauge-mask {
      position: absolute;
      bottom: 0;
      left: 10px;
      right: 10px;
      height: 80px;
      background: var(--bg-card);
      border-radius: 80px 80px 0 0;
    }
    .gauge-needle {
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 3px;
      height: 75px;
      background: var(--text-primary);
      transform-origin: bottom center;
      border-radius: 2px;
      transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .gauge-label {
      text-align: center;
      margin-top: 8px;
      font-size: 28px;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
    }

    /* Sentiment bars */
    .sentiment-bar-container {
      margin: 8px 0;
    }
    .sentiment-bar-label {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      margin-bottom: 4px;
    }
    .sentiment-bar {
      height: 6px;
      background: var(--bg-secondary);
      border-radius: 3px;
      overflow: hidden;
    }
    .sentiment-bar-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.5s ease;
    }

    /* News items */
    .news-item {
      padding: 10px 0;
      border-bottom: 1px solid rgba(42,49,66,0.4);
      font-size: 13px;
    }
    .news-item:last-child { border-bottom: none; }
    .news-meta {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 4px;
      font-size: 11px;
      color: var(--text-muted);
    }
    .news-sentiment-tag {
      padding: 1px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
    }

    /* Config form */
    .config-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .config-field label {
      display: block;
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }
    .config-field input,
    .config-field select {
      width: 100%;
      padding: 8px 12px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
    }
    .config-field input:focus,
    .config-field select:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    /* Buttons */
    .btn {
      padding: 8px 20px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.15s;
      font-family: 'Inter', sans-serif;
    }
    .btn-primary {
      background: var(--accent-blue);
      color: white;
    }
    .btn-primary:hover { background: #2563eb; }
    .btn-success {
      background: var(--accent-green);
      color: white;
    }
    .btn-success:hover { background: #059669; }
    .btn-danger {
      background: var(--accent-red);
      color: white;
    }
    .btn-outline {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
    }
    .btn-outline:hover {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }
    .btn-group { display: flex; gap: 8px; }

    /* Ticker selector */
    .ticker-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .ticker-pill {
      padding: 4px 12px;
      border-radius: 16px;
      border: 1px solid var(--border);
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
      transition: all 0.15s;
      background: transparent;
      color: var(--text-secondary);
    }
    .ticker-pill:hover { border-color: var(--accent-blue); color: var(--accent-blue); }
    .ticker-pill.active {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }

    /* Progress bar */
    .progress-bar {
      height: 4px;
      background: var(--bg-secondary);
      border-radius: 2px;
      overflow: hidden;
      margin: 8px 0;
    }
    .progress-fill {
      height: 100%;
      border-radius: 2px;
      transition: width 0.3s ease;
      background: linear-gradient(90deg, var(--accent-blue), var(--accent-cyan));
    }

    /* Scrollable */
    .scrollable { max-height: 400px; overflow-y: auto; }
    .scrollable::-webkit-scrollbar { width: 6px; }
    .scrollable::-webkit-scrollbar-track { background: transparent; }
    .scrollable::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

    /* Risk meter */
    .risk-levels {
      display: flex;
      gap: 4px;
      margin: 8px 0;
    }
    .risk-bar {
      flex: 1;
      height: 8px;
      border-radius: 4px;
      background: var(--bg-secondary);
    }
    .risk-bar.active-green { background: var(--accent-green); }
    .risk-bar.active-yellow { background: var(--accent-yellow); }
    .risk-bar.active-red { background: var(--accent-red); }

    /* Breakout scanner */
    .scanner-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-bottom: 1px solid rgba(42,49,66,0.3);
      font-size: 12px;
      cursor: pointer;
      transition: background 0.15s;
    }
    .scanner-row:hover { background: var(--bg-card-hover); }
    .scanner-row:last-child { border-bottom: none; }
    .scanner-ticker {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 700;
      font-size: 13px;
      min-width: 48px;
    }
    .scanner-status {
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      white-space: nowrap;
    }
    .scanner-bar {
      flex: 1;
      height: 6px;
      background: var(--bg-primary);
      border-radius: 3px;
      position: relative;
      overflow: visible;
    }
    .scanner-bar-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.3s ease;
    }
    .scanner-price {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      min-width: 56px;
      text-align: right;
    }
    .scanner-pct {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      min-width: 52px;
      text-align: right;
      font-weight: 600;
    }

    /* Live position card */
    .position-card {
      padding: 16px;
      border-radius: 10px;
      border: 1px solid;
      margin-bottom: 16px;
    }
    .position-card .position-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .position-card .position-dir {
      font-size: 14px;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
    }
    .position-card .target-row {
      display: flex;
      gap: 6px;
      margin-top: 10px;
    }
    .position-card .target-pip {
      flex: 1;
      text-align: center;
      padding: 4px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .grid-4 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .grid-3 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .grid-2-1, .grid-1-2 { grid-template-columns: minmax(0, 1fr); }
    }
    @media (max-width: 768px) {
      .grid-2, .grid-4, .grid-3 { grid-template-columns: minmax(0, 1fr); }
      .nav-tabs { display: none; }
    }

    /* Loading spinner */
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top-color: var(--accent-blue);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Simulation controls */
    .sim-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    .sim-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 20px;
      font-weight: 600;
      min-width: 90px;
    }
    .sim-speed {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      color: var(--text-muted);
    }

    /* Analyst ratings bar */
    .analyst-bar {
      display: flex;
      height: 24px;
      border-radius: 4px;
      overflow: hidden;
      margin: 8px 0;
    }
    .analyst-bar div {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 600;
      color: white;
      min-width: 20px;
    }

    /* Tab content */
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* Metric row */
    .metric-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid rgba(42,49,66,0.3);
      font-size: 13px;
    }
    .metric-row:last-child { border-bottom: none; }
    .metric-label { color: var(--text-secondary); }
    .metric-value { font-family: 'JetBrains Mono', monospace; font-weight: 500; }

    /* Canvas chart styles */
    .canvas-chart {
      width: 100%;
      display: block;
      background: var(--bg-secondary);
      border-radius: 8px;
    }

    /* Zoom controls */
    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .zoom-btn {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }
    .zoom-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
    .zoom-btn:active { transform: scale(0.92); }
    .zoom-label {
      font-size: 11px;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-secondary);
      min-width: 32px;
      text-align: center;
    }

    /* Context help / explainer boxes */
    .explainer {
      padding: 12px 16px;
      background: rgba(59,130,246,0.06);
      border-left: 3px solid var(--accent-blue);
      border-radius: 0 8px 8px 0;
      font-size: 13px;
      line-height: 1.6;
      color: var(--text-secondary);
      margin-bottom: 16px;
    }
    .explainer strong { color: var(--text-primary); }
    .explainer em { color: var(--accent-blue); font-style: normal; font-weight: 500; }

    /* Strategy phase indicator */
    .phase-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 16px;
    }
    .phase-indicator .phase-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .phase-indicator .phase-label { font-weight: 600; }
    .phase-indicator .phase-desc { color: var(--text-secondary); }

    /* Learn tab styles */
    .learn-section {
      margin-bottom: 24px;
    }
    .learn-section h2 {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 12px;
      color: var(--text-primary);
    }
    .learn-section h3 {
      font-size: 15px;
      font-weight: 600;
      margin: 16px 0 8px;
      color: var(--accent-blue);
    }
    .learn-section p, .learn-section li {
      font-size: 14px;
      line-height: 1.7;
      color: var(--text-secondary);
    }
    .learn-section ul, .learn-section ol {
      padding-left: 20px;
      margin: 8px 0;
    }
    .learn-section li { margin-bottom: 6px; }
    .learn-section strong { color: var(--text-primary); }
    .learn-grid-item {
      padding: 16px;
      background: var(--bg-secondary);
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    .learn-grid-item .number {
      font-size: 28px;
      font-weight: 800;
      color: var(--accent-blue);
      font-family: 'JetBrains Mono', monospace;
      margin-bottom: 8px;
    }
    .learn-grid-item h4 {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 6px;
    }
    .learn-grid-item p {
      font-size: 13px;
      line-height: 1.5;
      color: var(--text-secondary);
      margin: 0;
    }

    /* Metric explanation tooltip */
    .metric-row .metric-hint {
      font-size: 11px;
      color: var(--text-muted);
      font-family: 'Inter', sans-serif;
      font-weight: 400;
    }

    /* Overview grid — auto-fill guarantees every card is the same width */
    .overview-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 16px;
    }
    .overview-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      overflow: hidden;
      min-width: 0; /* prevent grid blowout */
    }
    .overview-card:hover {
      border-color: var(--accent-blue);
      background: var(--bg-card-hover);
      transform: translateY(-2px);
      box-shadow: 0 8px 16px rgba(0,0,0,0.3);
    }
    .overview-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }
    .overview-ticker {
      font-size: 18px;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
    }
    .overview-name {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .overview-sector {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 10px;
      background: rgba(59,130,246,0.1);
      color: var(--accent-blue);
      font-weight: 500;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .overview-price-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 8px;
      gap: 4px;
    }
    .overview-price {
      font-size: 18px;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
    }
    .overview-change {
      font-size: 12px;
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
      white-space: nowrap;
    }
    .overview-sparkline {
      width: 100%;
      height: 40px;
      margin: 8px 0;
    }
    .overview-metrics {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      margin-top: 10px;
    }
    .overview-metric {
      text-align: center;
      padding: 6px 4px;
      background: var(--bg-secondary);
      border-radius: 6px;
      min-width: 0;
      overflow: hidden;
    }
    .overview-metric-value {
      font-size: 12px;
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .overview-metric-label {
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 2px;
    }
    .overview-phase-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .overview-phase {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 10px;
      display: flex;
      align-items: center;
    }
    .overview-summary {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }
    @media (max-width: 768px) {
      .overview-summary { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    /* Force equal stat-box sizing inside overview-summary */
    .overview-summary .stat-box { width: 100%; }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- CDN Dependencies -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin></script>

  <!-- Our modules -->
  <script src="js/market-data.js"></script>
  <script src="js/orb-strategy.js"></script>
  <script src="js/backtester.js"></script>
  <script src="js/sentiment.js"></script>

  <!-- Main App -->
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback, useMemo } = React;

    const APP_VERSION = '1.3.0';

    // ─── Canvas Chart Component ──────────────────────────────
    function CandlestickChart({ candles, openingRange, signals, height = 350, title, onWheel }) {
      const canvasRef = useRef(null);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !onWheel) return;
        canvas.addEventListener('wheel', onWheel, { passive: false });
        return () => canvas.removeEventListener('wheel', onWheel);
      }, [onWheel]);

      useEffect(() => {
        if (!canvasRef.current || !candles || candles.length === 0) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = height + 'px';
        ctx.scale(dpr, dpr);

        const W = rect.width;
        const H = height;
        const padding = { top: 30, right: 60, bottom: 30, left: 10 };
        const chartW = W - padding.left - padding.right;
        const chartH = H - padding.top - padding.bottom;

        // Clear
        ctx.fillStyle = '#111827';
        ctx.fillRect(0, 0, W, H);

        // Price range
        let minPrice = Infinity, maxPrice = -Infinity;
        for (const c of candles) {
          if (c.low < minPrice) minPrice = c.low;
          if (c.high > maxPrice) maxPrice = c.high;
        }
        const priceRange = maxPrice - minPrice || 1;
        const pricePad = priceRange * 0.05;
        minPrice -= pricePad;
        maxPrice += pricePad;
        const totalRange = maxPrice - minPrice;

        const toX = (i) => padding.left + (i / (candles.length - 1 || 1)) * chartW;
        const toY = (p) => padding.top + (1 - (p - minPrice) / totalRange) * chartH;

        // Grid lines
        ctx.strokeStyle = 'rgba(42,49,66,0.5)';
        ctx.lineWidth = 0.5;
        const gridLines = 6;
        for (let i = 0; i <= gridLines; i++) {
          const y = padding.top + (i / gridLines) * chartH;
          const price = maxPrice - (i / gridLines) * totalRange;
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(W - padding.right, y);
          ctx.stroke();
          // Price label
          ctx.fillStyle = '#6b7280';
          ctx.font = '10px JetBrains Mono, monospace';
          ctx.textAlign = 'left';
          ctx.fillText(price.toFixed(2), W - padding.right + 5, y + 3);
        }

        // Time labels
        const timeLabels = [0, Math.floor(candles.length * 0.25), Math.floor(candles.length * 0.5),
                           Math.floor(candles.length * 0.75), candles.length - 1];
        ctx.fillStyle = '#6b7280';
        ctx.font = '10px JetBrains Mono, monospace';
        ctx.textAlign = 'center';
        for (const idx of timeLabels) {
          if (idx < candles.length) {
            const t = new Date(candles[idx].time);
            const label = t.getHours().toString().padStart(2,'0') + ':' + t.getMinutes().toString().padStart(2,'0');
            ctx.fillText(label, toX(idx), H - 8);
          }
        }

        // Opening Range highlight
        if (openingRange) {
          const orEndIdx = Math.min(openingRange.orCandles?.length || 15, candles.length);
          ctx.fillStyle = 'rgba(59,130,246,0.06)';
          ctx.fillRect(padding.left, toY(openingRange.high), toX(orEndIdx) - padding.left, toY(openingRange.low) - toY(openingRange.high));

          // OR High line
          ctx.strokeStyle = 'rgba(59,130,246,0.5)';
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(padding.left, toY(openingRange.high));
          ctx.lineTo(W - padding.right, toY(openingRange.high));
          ctx.stroke();

          // OR Low line
          ctx.beginPath();
          ctx.moveTo(padding.left, toY(openingRange.low));
          ctx.lineTo(W - padding.right, toY(openingRange.low));
          ctx.stroke();
          ctx.setLineDash([]);

          // Labels
          ctx.fillStyle = '#3b82f6';
          ctx.font = '10px Inter, sans-serif';
          ctx.textAlign = 'right';
          ctx.fillText('OR High ' + openingRange.high.toFixed(2), W - padding.right - 5, toY(openingRange.high) - 4);
          ctx.fillText('OR Low ' + openingRange.low.toFixed(2), W - padding.right - 5, toY(openingRange.low) + 12);
        }

        // Candles
        const candleWidth = Math.max(1, (chartW / candles.length) * 0.6);
        for (let i = 0; i < candles.length; i++) {
          const c = candles[i];
          const x = toX(i);
          const isGreen = c.close >= c.open;
          const color = isGreen ? '#10b981' : '#ef4444';

          // Wick
          ctx.strokeStyle = color;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, toY(c.high));
          ctx.lineTo(x, toY(c.low));
          ctx.stroke();

          // Body
          const bodyTop = toY(Math.max(c.open, c.close));
          const bodyBottom = toY(Math.min(c.open, c.close));
          const bodyHeight = Math.max(1, bodyBottom - bodyTop);

          ctx.fillStyle = color;
          ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
        }

        // Signals (entry/exit markers)
        if (signals) {
          for (const sig of signals) {
            const idx = candles.findIndex(c => c.time >= sig.time);
            if (idx < 0) continue;
            const x = toX(idx);

            if (sig.type === 'ENTRY') {
              const y = toY(sig.price);
              ctx.fillStyle = sig.direction === 'LONG' ? '#10b981' : '#ef4444';
              // Triangle marker
              ctx.beginPath();
              if (sig.direction === 'LONG') {
                ctx.moveTo(x, y + 3);
                ctx.lineTo(x - 6, y + 12);
                ctx.lineTo(x + 6, y + 12);
              } else {
                ctx.moveTo(x, y - 3);
                ctx.lineTo(x - 6, y - 12);
                ctx.lineTo(x + 6, y - 12);
              }
              ctx.fill();
            } else if (sig.type === 'EXIT') {
              const y = toY(sig.price);
              ctx.fillStyle = '#f59e0b';
              ctx.beginPath();
              ctx.arc(x, y, 5, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#0a0e17';
              ctx.font = 'bold 8px sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText('X', x, y + 3);
            }
          }
        }

        // Title
        if (title) {
          ctx.fillStyle = '#9ca3af';
          ctx.font = '12px Inter, sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText(title, padding.left + 5, 18);
        }

      }, [candles, openingRange, signals, height, title]);

      return <canvas ref={canvasRef} className="canvas-chart" style={{ height: height + 'px' }} />;
    }

    // ─── Line Chart Component ──────────────────────────────
    function LineChart({ data, height = 200, color = '#3b82f6', fillColor, yFormat, title, showZeroLine }) {
      const canvasRef = useRef(null);

      useEffect(() => {
        if (!canvasRef.current || !data || data.length === 0) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = height + 'px';
        ctx.scale(dpr, dpr);

        const W = rect.width;
        const H = height;
        const padding = { top: 25, right: 55, bottom: 20, left: 10 };
        const chartW = W - padding.left - padding.right;
        const chartH = H - padding.top - padding.bottom;

        ctx.fillStyle = '#111827';
        ctx.fillRect(0, 0, W, H);

        let minVal = Math.min(...data);
        let maxVal = Math.max(...data);
        if (showZeroLine) {
          minVal = Math.min(minVal, 0);
          maxVal = Math.max(maxVal, 0);
        }
        const range = maxVal - minVal || 1;
        const pad = range * 0.05;
        minVal -= pad;
        maxVal += pad;
        const totalRange = maxVal - minVal;

        const toX = (i) => padding.left + (i / (data.length - 1 || 1)) * chartW;
        const toY = (v) => padding.top + (1 - (v - minVal) / totalRange) * chartH;

        // Grid
        ctx.strokeStyle = 'rgba(42,49,66,0.5)';
        ctx.lineWidth = 0.5;
        for (let i = 0; i <= 4; i++) {
          const y = padding.top + (i / 4) * chartH;
          const val = maxVal - (i / 4) * totalRange;
          ctx.beginPath(); ctx.moveTo(padding.left, y); ctx.lineTo(W - padding.right, y); ctx.stroke();
          ctx.fillStyle = '#6b7280';
          ctx.font = '10px JetBrains Mono, monospace';
          ctx.textAlign = 'left';
          ctx.fillText(yFormat ? yFormat(val) : val.toFixed(2), W - padding.right + 5, y + 3);
        }

        // Zero line
        if (showZeroLine && minVal < 0 && maxVal > 0) {
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(padding.left, toY(0)); ctx.lineTo(W - padding.right, toY(0)); ctx.stroke();
        }

        // Fill
        if (fillColor) {
          ctx.beginPath();
          ctx.moveTo(toX(0), toY(data[0]));
          for (let i = 1; i < data.length; i++) ctx.lineTo(toX(i), toY(data[i]));
          ctx.lineTo(toX(data.length - 1), padding.top + chartH);
          ctx.lineTo(toX(0), padding.top + chartH);
          ctx.closePath();
          const grad = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartH);
          grad.addColorStop(0, fillColor);
          grad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grad;
          ctx.fill();
        }

        // Line
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(toX(0), toY(data[0]));
        for (let i = 1; i < data.length; i++) ctx.lineTo(toX(i), toY(data[i]));
        ctx.stroke();

        // Title
        if (title) {
          ctx.fillStyle = '#9ca3af';
          ctx.font = '12px Inter, sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText(title, padding.left + 5, 16);
        }
      }, [data, height, color, fillColor, yFormat, title, showZeroLine]);

      return <canvas ref={canvasRef} className="canvas-chart" style={{ height: height + 'px' }} />;
    }

    // ─── Bar Chart Component ──────────────────────────────
    function BarChart({ data, labels, height = 200, title, colorFn, onWheel }) {
      const canvasRef = useRef(null);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !onWheel) return;
        canvas.addEventListener('wheel', onWheel, { passive: false });
        return () => canvas.removeEventListener('wheel', onWheel);
      }, [onWheel]);

      useEffect(() => {
        if (!canvasRef.current || !data || data.length === 0) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = height + 'px';
        ctx.scale(dpr, dpr);

        const W = rect.width;
        const H = height;
        const padding = { top: 25, right: 10, bottom: 25, left: 10 };
        const chartW = W - padding.left - padding.right;
        const chartH = H - padding.top - padding.bottom;

        ctx.fillStyle = '#111827';
        ctx.fillRect(0, 0, W, H);

        const maxVal = Math.max(...data.map(Math.abs), 0.01);
        const hasNegative = data.some(d => d < 0);
        const zeroY = hasNegative ? padding.top + chartH * 0.5 : padding.top + chartH;
        const barWidth = Math.max(2, chartW / data.length * 0.7);
        const gap = chartW / data.length;

        for (let i = 0; i < data.length; i++) {
          const x = padding.left + i * gap + (gap - barWidth) / 2;
          const val = data[i];
          const barH = (Math.abs(val) / maxVal) * (hasNegative ? chartH * 0.45 : chartH);
          const y = val >= 0 ? zeroY - barH : zeroY;

          ctx.fillStyle = colorFn ? colorFn(val, i) : (val >= 0 ? '#10b981' : '#ef4444');
          ctx.fillRect(x, y, barWidth, barH);
        }

        if (hasNegative) {
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(padding.left, zeroY); ctx.lineTo(W - padding.right, zeroY); ctx.stroke();
        }

        if (title) {
          ctx.fillStyle = '#9ca3af';
          ctx.font = '12px Inter, sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText(title, padding.left + 5, 16);
        }
      }, [data, labels, height, title, colorFn]);

      return <canvas ref={canvasRef} className="canvas-chart" style={{ height: height + 'px' }} />;
    }

    // ─── Sentiment Gauge Component ──────────────────────────
    function SentimentGauge({ score, size = 180 }) {
      const rotation = ((score + 100) / 200) * 180 - 90; // -90 to 90 degrees
      const color = score > 20 ? 'var(--accent-green)' : score < -20 ? 'var(--accent-red)' : 'var(--accent-yellow)';
      return (
        <div style={{ textAlign: 'center' }}>
          <div className="sentiment-gauge" style={{ width: size, height: size * 0.55, margin: '0 auto' }}>
            <div className="gauge-bg" style={{ width: size, height: size * 0.5 }}>
              <div className="gauge-mask" style={{ height: size * 0.4, left: size * 0.05, right: size * 0.05 }} />
            </div>
            <div className="gauge-needle" style={{ transform: `rotate(${rotation}deg)`, height: size * 0.38 }} />
          </div>
          <div className="gauge-label" style={{ color, fontSize: size * 0.16 }}>{score > 0 ? '+' : ''}{score}</div>
        </div>
      );
    }

    // ─── Risk Meter Component ──────────────────────────────
    function RiskMeter({ level }) {
      const bars = 10;
      return (
        <div className="risk-levels">
          {Array.from({ length: bars }, (_, i) => {
            const active = i < level;
            const cls = i < 3 ? 'active-green' : i < 7 ? 'active-yellow' : 'active-red';
            return <div key={i} className={`risk-bar ${active ? cls : ''}`} />;
          })}
        </div>
      );
    }

    // ─── Mini Sparkline for Overview ──────────────────────────────
    function MiniSparkline({ data, color, width = '100%', height = 40 }) {
      const canvasRef = useRef(null);
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data || data.length < 2) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width = canvas.offsetWidth * 2;
        const H = canvas.height = canvas.offsetHeight * 2;
        ctx.clearRect(0, 0, W, H);

        const min = Math.min(...data);
        const max = Math.max(...data);
        const range = max - min || 1;
        const pad = 4;

        // Draw area fill
        ctx.beginPath();
        ctx.moveTo(pad, H - pad);
        for (let i = 0; i < data.length; i++) {
          const x = pad + (i / (data.length - 1)) * (W - 2 * pad);
          const y = H - pad - ((data[i] - min) / range) * (H - 2 * pad);
          ctx.lineTo(x, y);
        }
        ctx.lineTo(W - pad, H - pad);
        ctx.closePath();
        const grad = ctx.createLinearGradient(0, 0, 0, H);
        grad.addColorStop(0, color + '30');
        grad.addColorStop(1, color + '05');
        ctx.fillStyle = grad;
        ctx.fill();

        // Draw line
        ctx.beginPath();
        for (let i = 0; i < data.length; i++) {
          const x = pad + (i / (data.length - 1)) * (W - 2 * pad);
          const y = H - pad - ((data[i] - min) / range) * (H - 2 * pad);
          i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
      }, [data, color]);

      return <canvas ref={canvasRef} style={{ width, height, display: 'block' }} />;
    }

    // ─── Ticker List ──────────────────────────────
    const ALL_TICKERS = Object.keys(MarketData.STOCK_PROFILES);

    // ─── MAIN APP ──────────────────────────────
    function App() {
      const [activeTab, setActiveTab] = useState('overview');
      const [selectedTicker, setSelectedTicker] = useState('SPY');
      const [simRunning, setSimRunning] = useState(false);
      const [simSpeed, setSimSpeed] = useState(50);
      const [simMinute, setSimMinute] = useState(0);
      const simRef = useRef(null);
      const [currentDay, setCurrentDay] = useState(null);
      const [strategyResult, setStrategyResult] = useState(null);
      const [backtestResult, setBacktestResult] = useState(null);
      const [sentimentData, setSentimentData] = useState(null);
      const [watchlistSentiment, setWatchlistSentiment] = useState(null);
      const [backtestRunning, setBacktestRunning] = useState(false);

      // Admin: log capture
      const [logs, setLogs] = useState([]);
      const [cacheStatus, setCacheStatus] = useState('');
      const [swStatus, setSwStatus] = useState('');
      const logsEndRef = useRef(null);

      useEffect(() => {
        const ts = () => new Date().toLocaleTimeString('en-GB', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
        const push = (level, args) => {
          const msg = args.map(a => typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a)).join(' ');
          setLogs(prev => [...prev.slice(-499), { time: ts(), level, msg }]);
        };
        const origLog = console.log, origWarn = console.warn, origError = console.error, origInfo = console.info;
        console.log = (...a) => { origLog(...a); push('log', a); };
        console.warn = (...a) => { origWarn(...a); push('warn', a); };
        console.error = (...a) => { origError(...a); push('error', a); };
        console.info = (...a) => { origInfo(...a); push('info', a); };
        const onError = (e) => push('error', [e.message || String(e)]);
        const onRejection = (e) => push('error', ['Unhandled rejection:', e.reason]);
        window.addEventListener('error', onError);
        window.addEventListener('unhandledrejection', onRejection);
        return () => {
          console.log = origLog; console.warn = origWarn; console.error = origError; console.info = origInfo;
          window.removeEventListener('error', onError);
          window.removeEventListener('unhandledrejection', onRejection);
        };
      }, []);

      // Strategy config state
      const [stratConfig, setStratConfig] = useState({
        openingRangeMinutes: 15,
        confirmationType: 'close',
        volumeConfirmation: true,
        volumeMultiplier: 1.5,
        vwapConfirmation: true,
        sentimentConfirmation: true,
        minConfirmations: 2,
        riskPerTrade: 0.02,
        maxTradesPerDay: 2,
        trailingStop: true,
        breakEvenAfterTarget1: true,
      });

      // Backtest config state
      const [btConfig, setBtConfig] = useState({
        startingCapital: 100000,
        numDays: 60,
        startDate: '2025-11-01',
        ticker: 'SPY',
      });

      const today = useMemo(() => {
        const d = new Date();
        return d.toISOString().slice(0, 10);
      }, []);

      // Generate day data on ticker change
      useEffect(() => {
        const seed = selectedTicker.charCodeAt(0) * 10000 + Date.now() % 10000;
        const profile = MarketData.STOCK_PROFILES[selectedTicker];
        const dayData = MarketData.generateIntradayData(selectedTicker, new Date(), seed, profile.basePrice);
        setCurrentDay(dayData);
        setSimMinute(0);
        setStrategyResult(null);

        // Run sentiment
        const sentiment = SentimentAnalysis.analyze(selectedTicker, today, profile.basePrice);
        setSentimentData(sentiment);
      }, [selectedTicker, today]);

      // Run strategy on current day data
      useEffect(() => {
        if (!currentDay) return;
        const visibleCandles = simRunning ? currentDay.candles.slice(0, simMinute + 1) : currentDay.candles;
        if (visibleCandles.length > stratConfig.openingRangeMinutes) {
          // Calculate VWAP for each candle
          const vwapData = [];
          let cumPV = 0, cumVol = 0;
          for (const c of visibleCandles) {
            const typical = (c.high + c.low + c.close) / 3;
            cumPV += typical * c.volume;
            cumVol += c.volume;
            vwapData.push(cumVol > 0 ? cumPV / cumVol : c.close);
          }

          // Get sentiment score
          const sentimentScore = sentimentData?.compositeScore || 0;

          const result = ORBStrategy.runDay(visibleCandles, stratConfig, 100000, vwapData, sentimentScore);
          setStrategyResult(result);
        }
      }, [currentDay, simMinute, simRunning, stratConfig, sentimentData]);

      // Watchlist sentiment
      useEffect(() => {
        const results = SentimentAnalysis.analyzeWatchlist(ALL_TICKERS, today);
        setWatchlistSentiment(results);
      }, [today]);

      // Pre-generated day data for all tickers (stable seeds, generated once)
      const allDayData = useMemo(() => {
        const data = {};
        ALL_TICKERS.forEach(ticker => {
          const profile = MarketData.STOCK_PROFILES[ticker];
          const seed = ticker.charCodeAt(0) * 10000 + ticker.charCodeAt(1) * 100;
          data[ticker] = MarketData.generateIntradayData(ticker, new Date(), seed, profile.basePrice);
        });
        return data;
      }, [today]);

      // All-ticker data: recomputes during sim to show live breakout status
      const allTickerData = useMemo(() => {
        const simActive = simRunning || simMinute > 0;
        return ALL_TICKERS.map(ticker => {
          const profile = MarketData.STOCK_PROFILES[ticker];
          const dayData = allDayData[ticker];
          if (!dayData) return null;
          const allCandles = dayData.candles;
          // During simulation, all tickers advance to the same minute
          const candles = simActive ? allCandles.slice(0, simMinute + 1) : allCandles;

          // Calculate VWAP for each candle
          const vwapData = [];
          let cumPV = 0, cumVol = 0;
          for (const c of candles) {
            const typical = (c.high + c.low + c.close) / 3;
            cumPV += typical * c.volume;
            cumVol += c.volume;
            vwapData.push(cumVol > 0 ? cumPV / cumVol : c.close);
          }

          const sentiment = SentimentAnalysis.analyze(ticker, today, profile.basePrice);
          const sentimentScore = sentiment?.compositeScore || 0;
          
          const result = candles.length > stratConfig.openingRangeMinutes
            ? ORBStrategy.runDay(candles, stratConfig, 100000, vwapData, sentimentScore)
            : null;

          const lastCandle = candles[candles.length - 1];
          const closePrice = lastCandle.close;
          const openPrice = dayData.openPrice;
          const change = closePrice - openPrice;
          const changePct = openPrice ? (change / openPrice * 100) : 0;
          const pnl = result?.summary?.totalPnL || 0;

          // Sparkline: sample every 10th candle close
          const sparkData = [];
          for (let i = 0; i < candles.length; i += 10) sparkData.push(candles[i].close);
          sparkData.push(candles[candles.length - 1].close);

          // Opening range data
          const or = result?.openingRange || null;

          // Breakout status
          let breakoutStatus = 'forming'; // before OR forms
          let proximity = 0; // % distance from nearest OR boundary
          let vwap = null;
          if (or) {
            // Calculate VWAP
            let cumPV = 0, cumVol = 0;
            for (const c of candles) {
              const typical = (c.high + c.low + c.close) / 3;
              cumPV += typical * c.volume;
              cumVol += c.volume;
            }
            vwap = cumVol > 0 ? cumPV / cumVol : closePrice;

            const aboveHigh = closePrice > or.high;
            const belowLow = closePrice < or.low;
            const distHigh = or.high > 0 ? ((closePrice - or.high) / or.high * 100) : 0;
            const distLow = or.low > 0 ? ((or.low - closePrice) / or.low * 100) : 0;

            // Check if currently in active trade
            const activeTrade = result?.trades?.find(t => !t.exitTime);

            if (activeTrade) {
              breakoutStatus = activeTrade.direction === 'LONG' ? 'long_active' : 'short_active';
              proximity = activeTrade.direction === 'LONG' ? distHigh : distLow;
            } else if (aboveHigh) {
              breakoutStatus = 'above_range';
              proximity = distHigh;
            } else if (belowLow) {
              breakoutStatus = 'below_range';
              proximity = distLow;
            } else {
              breakoutStatus = 'in_range';
              // How close to nearest boundary (negative = approaching from inside)
              const pctToHigh = ((or.high - closePrice) / or.rangeSize * 100);
              const pctToLow = ((closePrice - or.low) / or.rangeSize * 100);
              proximity = Math.min(pctToHigh, pctToLow);
            }
          }

          // Volume relative to OR average
          const rvol = or && or.avgVolume > 0 && lastCandle
            ? lastCandle.volume / or.avgVolume : 1;

          // Strategy phase
          let phase = { label: 'Complete', color: 'var(--accent-purple)' };
          const trades = result?.trades || [];
          if (!result) {
            phase = { label: 'Forming OR', color: 'var(--accent-blue)' };
          } else if (trades.length === 0) {
            phase = { label: 'No Trades', color: 'var(--text-muted)' };
          } else {
            const wins = trades.filter(t => t.totalPnL > 0).length;
            phase = { label: `${wins}W / ${trades.length - wins}L`, color: wins > trades.length - wins ? 'var(--accent-green)' : 'var(--accent-red)' };
          }

          return {
            ticker, profile, closePrice, openPrice, change, changePct,
            pnl, sentiment, sparkData, phase, trades,
            compositeScore: sentiment?.compositeScore || 0,
            or, breakoutStatus, proximity, vwap, rvol,
          };
        }).filter(Boolean);
      }, [today, stratConfig, simMinute, simRunning, allDayData]);

      // Simulation timer
      useEffect(() => {
        if (simRunning && currentDay) {
          simRef.current = setInterval(() => {
            setSimMinute(prev => {
              if (prev >= currentDay.candles.length - 1) {
                setSimRunning(false);
                return prev;
              }
              return prev + 1;
            });
          }, Math.max(10, 1000 / simSpeed));
        }
        return () => { if (simRef.current) clearInterval(simRef.current); };
      }, [simRunning, simSpeed, currentDay]);

      const toggleSim = () => {
        if (!simRunning && simMinute >= (currentDay?.candles.length || 390) - 1) {
          setSimMinute(0);
        }
        setSimRunning(!simRunning);
      };

      const resetSim = () => {
        setSimRunning(false);
        setSimMinute(0);
        setStrategyResult(null);
      };

      const runBacktest = () => {
        setBacktestRunning(true);
        setTimeout(() => {
          const result = Backtester.run({
            ...btConfig,
            strategyConfig: stratConfig,
          });
          // Monte Carlo
          result.monteCarlo = Backtester.monteCarloSimulation(result.trades, btConfig.startingCapital);
          setBacktestResult(result);
          setBacktestRunning(false);
        }, 100);
      };

      const profile = MarketData.STOCK_PROFILES[selectedTicker];

      const visibleCandles = useMemo(() => {
        if (!currentDay) return [];
        return simRunning || simMinute > 0
          ? currentDay.candles.slice(0, simMinute + 1)
          : currentDay.candles;
      }, [currentDay, simMinute, simRunning]);

      const currentPrice = visibleCandles.length > 0 ? visibleCandles[visibleCandles.length - 1].close : 0;
      const openPrice = currentDay?.openPrice || 0;
      const priceChange = currentPrice - openPrice;
      const priceChangePct = openPrice ? (priceChange / openPrice * 100) : 0;

      const simTimeStr = useMemo(() => {
        if (!currentDay || visibleCandles.length === 0) return '09:30';
        const t = new Date(visibleCandles[visibleCandles.length - 1].time);
        return t.getHours().toString().padStart(2, '0') + ':' + t.getMinutes().toString().padStart(2, '0');
      }, [visibleCandles, currentDay]);

      const dayPnL = strategyResult?.summary?.totalPnL || 0;

      // ─── Render Functions ──────────────────────────────
      const renderOverview = () => {
        const totalPnL = allTickerData.reduce((sum, d) => sum + d.pnl, 0);
        const avgSentiment = allTickerData.reduce((sum, d) => sum + d.compositeScore, 0) / allTickerData.length;
        const winners = allTickerData.filter(d => d.changePct > 0).length;
        const totalTrades = allTickerData.reduce((sum, d) => sum + d.trades.length, 0);

        return (
          <div>
            <div className="explainer">
              <strong>Market Overview</strong> shows all 10 tracked stocks at a glance.
              Each card displays today's price action, strategy P&amp;L, and sentiment.
              Click any card to view its sentiment details.
            </div>

            {/* Summary stats */}
            <div className="overview-summary">
              <div className="stat-box">
                <div className={`stat-value ${totalPnL >= 0 ? 'positive' : 'negative'}`}>
                  ${totalPnL.toFixed(0)}
                </div>
                <div className="stat-label">Total Strategy P&L</div>
              </div>
              <div className="stat-box">
                <div className={`stat-value ${avgSentiment >= 0 ? 'positive' : 'negative'}`}>
                  {avgSentiment > 0 ? '+' : ''}{avgSentiment.toFixed(1)}
                </div>
                <div className="stat-label">Avg Sentiment</div>
              </div>
              <div className="stat-box">
                <div className="stat-value" style={{ color: 'var(--accent-cyan)' }}>
                  {winners} / {allTickerData.length}
                </div>
                <div className="stat-label">Stocks Up</div>
              </div>
              <div className="stat-box">
                <div className="stat-value" style={{ color: 'var(--accent-blue)' }}>
                  {totalTrades}
                </div>
                <div className="stat-label">Total Trades</div>
              </div>
            </div>

            {/* Stock cards grid */}
            <div className="overview-grid">
              {allTickerData.map(d => (
                <div key={d.ticker} className="overview-card"
                  onClick={() => { setSelectedTicker(d.ticker); setActiveTab('sentiment'); }}>
                  <div className="overview-card-header">
                    <div>
                      <div className="overview-ticker">{d.ticker}</div>
                      <div className="overview-name">{d.profile.name}</div>
                    </div>
                    <span className="overview-sector">{d.profile.sector}</span>
                  </div>

                  <div className="overview-price-row">
                    <span className="overview-price" style={{ color: d.change >= 0 ? 'var(--accent-green)' : 'var(--accent-red)' }}>
                      ${d.closePrice.toFixed(2)}
                    </span>
                    <span className="overview-change" style={{ color: d.change >= 0 ? 'var(--accent-green)' : 'var(--accent-red)' }}>
                      {d.change >= 0 ? '+' : ''}{d.changePct.toFixed(2)}%
                    </span>
                  </div>

                  <MiniSparkline
                    data={d.sparkData}
                    color={d.change >= 0 ? '#10b981' : '#ef4444'}
                    height={40}
                  />

                  <div className="overview-metrics">
                    <div className="overview-metric">
                      <div className="overview-metric-value" style={{ color: d.pnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)' }}>
                        ${d.pnl.toFixed(0)}
                      </div>
                      <div className="overview-metric-label">P&L</div>
                    </div>
                    <div className="overview-metric">
                      <div className="overview-metric-value" style={{ color: d.compositeScore >= 0 ? 'var(--accent-green)' : 'var(--accent-red)' }}>
                        {d.compositeScore > 0 ? '+' : ''}{d.compositeScore}
                      </div>
                      <div className="overview-metric-label">Sentiment</div>
                    </div>
                    <div className="overview-metric">
                      <div className="overview-metric-value" style={{ color: d.phase.color }}>
                        {d.phase.label}
                      </div>
                      <div className="overview-metric-label">Trades</div>
                    </div>
                  </div>
                </div>
              ))}
            </div>

            {/* Selected Ticker Chart */}
            <div className="card" style={{ marginTop: 16 }}>
              <div className="card-header">
                <span className="card-title">{selectedTicker} - 1min</span>
                <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
                  <span className="card-badge" style={{
                    background: priceChange >= 0 ? 'rgba(16,185,129,0.15)' : 'rgba(239,68,68,0.15)',
                    color: priceChange >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'
                  }}>
                    {priceChange >= 0 ? '+' : ''}{priceChangePct.toFixed(2)}%
                  </span>
                </div>
              </div>

              {/* Simulation Controls */}
              <div className="sim-controls mb-16">
                <div className="btn-group">
                  <button className={`btn ${simRunning ? 'btn-danger' : 'btn-success'}`} onClick={toggleSim}>
                    {simRunning ? 'Pause' : (simMinute > 0 ? 'Resume' : 'Start Day')}
                  </button>
                  <button className="btn btn-outline" onClick={resetSim}>Reset</button>
                  <button className="btn btn-outline" style={{ color: 'var(--accent-cyan)', borderColor: 'var(--accent-cyan)' }}
                    onClick={() => { setSimSpeed(200); setSimMinute(0); setSimRunning(true); }}>
                    Auto Run
                  </button>
                </div>
                <div className="sim-time">{simTimeStr}</div>
                <div style={{ flex: 1 }}>
                  <div className="progress-bar">
                    <div className="progress-fill" style={{ width: `${(simMinute / 389) * 100}%` }} />
                  </div>
                </div>
                <div className="sim-speed">
                  <span>Speed:</span>
                  <input type="range" min="1" max="200" value={simSpeed}
                    onChange={(e) => setSimSpeed(Number(e.target.value))}
                    style={{ width: 80 }} />
                  <span className="mono">{simSpeed}x</span>
                </div>
              </div>

              {strategyResult?.openingRange && (
                <div className="or-info mb-16" style={{ marginBottom: 12 }}>
                  <span>OR ({stratConfig.openingRangeMinutes}min):</span>
                  <span>High: <strong>{strategyResult.openingRange.high.toFixed(2)}</strong></span>
                  <span>Low: <strong>{strategyResult.openingRange.low.toFixed(2)}</strong></span>
                  <span>Size: <strong>${strategyResult.openingRange.rangeSize.toFixed(2)}</strong> ({(strategyResult.openingRange.rangeSize / strategyResult.openingRange.openPrice * 100).toFixed(2)}%)</span>
                </div>
              )}
              <CandlestickChart
                candles={visibleCandles}
                openingRange={strategyResult?.openingRange}
                signals={strategyResult?.signals}
                height={340}
                title={`${selectedTicker} - ${simTimeStr} ET`}
              />
              <div style={{ borderTop: '1px solid var(--border)', marginTop: 4 }}>
                <BarChart
                  data={visibleCandles.map(c => c.volume)}
                  height={100}
                  title="Volume"
                  colorFn={(val, i) => {
                    return i < stratConfig.openingRangeMinutes ? 'rgba(59,130,246,0.6)' : 'rgba(107,114,128,0.4)';
                  }}
                />
              </div>
            </div>

            {/* Trade Log */}
            {strategyResult?.trades && strategyResult.trades.length > 0 && (
              <div className="card" style={{ marginTop: 16 }}>
                <div className="card-header">
                  <span className="card-title">Trade Log</span>
                  <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
                    <span className="card-badge" style={{ background: 'rgba(59,130,246,0.15)', color: 'var(--accent-blue)' }}>
                      {strategyResult.trades.length} trade{strategyResult.trades.length !== 1 ? 's' : ''}
                    </span>
                    <span className={`card-badge`} style={{
                      background: dayPnL >= 0 ? 'rgba(16,185,129,0.15)' : 'rgba(239,68,68,0.15)',
                      color: dayPnL >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'
                    }}>
                      {dayPnL >= 0 ? '+' : ''}${dayPnL.toFixed(2)}
                    </span>
                  </div>
                </div>
                <div className="scrollable">
                  <table className="trade-table">
                    <thead>
                      <tr>
                        <th>Dir</th>
                        <th>Entry</th>
                        <th>Exit</th>
                        <th>Shares</th>
                        <th>P&L</th>
                        <th>Duration</th>
                        <th>Reason</th>
                      </tr>
                    </thead>
                    <tbody>
                      {strategyResult.trades.map((trade, idx) => (
                        <tr key={idx}>
                          <td><span className={trade.direction === 'LONG' ? 'dir-long' : 'dir-short'}>{trade.direction}</span></td>
                          <td>${trade.entryPrice.toFixed(2)}</td>
                          <td>{trade.partialExits.length > 0 ? '$' + trade.partialExits[trade.partialExits.length - 1].price.toFixed(2) : '-'}</td>
                          <td>{trade.shares}</td>
                          <td className={trade.totalPnL >= 0 ? 'pnl-positive' : 'pnl-negative'}>
                            ${trade.totalPnL.toFixed(2)}
                          </td>
                          <td>{trade.durationMinutes}m</td>
                          <td style={{ color: 'var(--text-muted)', fontFamily: 'Inter, sans-serif' }}>{trade.exitReason}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            )}
          </div>
        );
      };

      // Breakout status helpers
      const getBreakoutLabel = (status) => {
        switch (status) {
          case 'forming': return { text: 'FORMING', color: 'var(--accent-blue)', bg: 'rgba(59,130,246,0.15)' };
          case 'in_range': return { text: 'IN RANGE', color: 'var(--accent-yellow)', bg: 'rgba(245,158,11,0.12)' };
          case 'above_range': return { text: 'ABOVE OR', color: 'var(--accent-green)', bg: 'rgba(16,185,129,0.15)' };
          case 'below_range': return { text: 'BELOW OR', color: 'var(--accent-red)', bg: 'rgba(239,68,68,0.15)' };
          case 'long_active': return { text: 'LONG', color: '#fff', bg: 'var(--accent-green)' };
          case 'short_active': return { text: 'SHORT', color: '#fff', bg: 'var(--accent-red)' };
          default: return { text: '...', color: 'var(--text-muted)', bg: 'var(--bg-secondary)' };
        }
      };

      // ─── Sentiment Tab ──────────────────────────────
      const renderSentiment = () => (
        <div>
          <div className="explainer">
            <strong>Pre-Market Sentiment</strong> aggregates news, social media, options flow, gap analysis, and analyst ratings
            into a composite score for each ticker. Positive scores suggest bullish conditions that favor long breakouts;
            negative scores favor short breakdowns. Use this to filter which ORB signals to trust.
            Click any ticker row to switch tickers.
          </div>
          {/* Watchlist overview */}
          <div className="card mb-16" style={{ marginBottom: 16 }}>
            <div className="card-header">
              <span className="card-title">Watchlist Sentiment Rankings - Pre-Market Analysis</span>
              <span style={{ color: 'var(--text-muted)', fontSize: 12 }}>{today}</span>
            </div>
            <table className="trade-table">
              <thead>
                <tr>
                  <th>Ticker</th>
                  <th>Name</th>
                  <th>Score</th>
                  <th>News</th>
                  <th>Social</th>
                  <th>Gap</th>
                  <th>Options</th>
                  <th>Recommendation</th>
                </tr>
              </thead>
              <tbody>
                {(watchlistSentiment || []).map((s, idx) => (
                  <tr key={s.ticker} style={{ cursor: 'pointer' }}
                      onClick={() => { setSelectedTicker(s.ticker); setActiveTab('sentiment'); }}>
                    <td style={{ fontWeight: 600 }}>{s.ticker}</td>
                    <td style={{ fontFamily: 'Inter, sans-serif', color: 'var(--text-secondary)' }}>
                      {MarketData.STOCK_PROFILES[s.ticker]?.name}
                    </td>
                    <td className={s.compositeScore > 0 ? 'pnl-positive' : 'pnl-negative'}>
                      {s.compositeScore > 0 ? '+' : ''}{s.compositeScore}
                    </td>
                    <td style={{ color: s.news.overallScore > 0 ? 'var(--accent-green)' : 'var(--accent-red)' }}>
                      {s.news.sentiment}
                    </td>
                    <td style={{ color: s.social.score > 0 ? 'var(--accent-green)' : 'var(--accent-red)' }}>
                      {s.social.sentiment}
                    </td>
                    <td className={s.gap.gapPercent > 0 ? 'pnl-positive' : 'pnl-negative'}>
                      {s.gap.gapPercent > 0 ? '+' : ''}{s.gap.gapPercent}%
                    </td>
                    <td style={{ color: s.options.score > 0 ? 'var(--accent-green)' : 'var(--accent-red)' }}>
                      {s.options.sentiment}
                    </td>
                    <td style={{ color: s.recommendation.color, fontFamily: 'Inter, sans-serif', fontWeight: 500 }}>
                      {s.recommendation.icon} {s.recommendation.action}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          {/* Detailed sentiment for selected ticker */}
          {sentimentData && (
            <div className="grid-2 mb-16" style={{ marginBottom: 16 }}>
              {/* Sentiment detail left */}
              <div className="card">
                <div className="card-header">
                  <span className="card-title">{selectedTicker} Detailed Sentiment</span>
                </div>
                <SentimentGauge score={sentimentData.compositeScore} size={200} />
                <div style={{ textAlign: 'center', marginTop: 8, fontSize: 16, fontWeight: 600, color: sentimentData.recommendation.color }}>
                  {sentimentData.recommendation.action}
                </div>
                <div style={{ textAlign: 'center', fontSize: 12, color: 'var(--text-muted)', marginTop: 4 }}>
                  Confidence: {(sentimentData.confidence * 100).toFixed(0)}%
                </div>

                <div style={{ marginTop: 16 }}>
                  <div className="card-title" style={{ marginBottom: 8 }}>Gap Analysis</div>
                  <div className="metric-row">
                    <span className="metric-label">Previous Close</span>
                    <span className="metric-value">${sentimentData.gap.previousClose}</span>
                  </div>
                  <div className="metric-row">
                    <span className="metric-label">Pre-Market Price</span>
                    <span className="metric-value">${sentimentData.gap.preMarketPrice}</span>
                  </div>
                  <div className="metric-row">
                    <span className="metric-label">Gap</span>
                    <span className={`metric-value ${sentimentData.gap.gapPercent > 0 ? 'positive' : 'negative'}`}>
                      {sentimentData.gap.gapPercent > 0 ? '+' : ''}{sentimentData.gap.gapPercent}% (${sentimentData.gap.gapDollar})
                    </span>
                  </div>
                  <div className="metric-row">
                    <span className="metric-label">Gap Type</span>
                    <span className="metric-value">{sentimentData.gap.gapType}</span>
                  </div>
                  <div className="metric-row">
                    <span className="metric-label">Fill Probability</span>
                    <span className="metric-value">{sentimentData.gap.gapFillProbability}%</span>
                  </div>
                </div>

                <div style={{ marginTop: 16 }}>
                  <div className="card-title" style={{ marginBottom: 8 }}>Options Flow</div>
                  <div className="metric-row">
                    <span className="metric-label">Put/Call Ratio</span>
                    <span className="metric-value">{sentimentData.options.putCallRatio}</span>
                  </div>
                  <div className="metric-row">
                    <span className="metric-label">Call Volume</span>
                    <span className="metric-value">{sentimentData.options.callVolume.toLocaleString()}</span>
                  </div>
                  <div className="metric-row">
                    <span className="metric-label">Put Volume</span>
                    <span className="metric-value">{sentimentData.options.putVolume.toLocaleString()}</span>
                  </div>
                  <div className="metric-row">
                    <span className="metric-label">Implied Move</span>
                    <span className="metric-value">{sentimentData.options.impliedMove}%</span>
                  </div>
                  <div className="metric-row">
                    <span className="metric-label">Unusual Activity</span>
                    <span className="metric-value">{sentimentData.options.unusualActivity ? 'YES' : 'No'}</span>
                  </div>
                </div>
              </div>

              {/* News + Social */}
              <div>
                {/* Analyst Ratings */}
                <div className="card" style={{ marginBottom: 16 }}>
                  <div className="card-header">
                    <span className="card-title">Analyst Ratings</span>
                    <span className="mono" style={{ fontSize: 13, color: 'var(--text-secondary)' }}>
                      {sentimentData.analysts.consensusRating} ({sentimentData.analysts.weightedScore}/5)
                    </span>
                  </div>
                  <div className="analyst-bar">
                    <div style={{ flex: sentimentData.analysts.strongBuy, background: '#059669' }}>
                      {sentimentData.analysts.strongBuy > 0 ? sentimentData.analysts.strongBuy : ''}
                    </div>
                    <div style={{ flex: sentimentData.analysts.buy, background: '#10b981' }}>
                      {sentimentData.analysts.buy > 0 ? sentimentData.analysts.buy : ''}
                    </div>
                    <div style={{ flex: sentimentData.analysts.hold, background: '#f59e0b' }}>
                      {sentimentData.analysts.hold > 0 ? sentimentData.analysts.hold : ''}
                    </div>
                    <div style={{ flex: sentimentData.analysts.sell, background: '#ef4444' }}>
                      {sentimentData.analysts.sell > 0 ? sentimentData.analysts.sell : ''}
                    </div>
                    <div style={{ flex: sentimentData.analysts.strongSell, background: '#b91c1c' }}>
                      {sentimentData.analysts.strongSell > 0 ? sentimentData.analysts.strongSell : ''}
                    </div>
                  </div>
                  <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 10, color: 'var(--text-muted)', marginTop: 4 }}>
                    <span>Strong Buy</span><span>Buy</span><span>Hold</span><span>Sell</span><span>Strong Sell</span>
                  </div>
                  <div className="metric-row" style={{ marginTop: 8 }}>
                    <span className="metric-label">Price Target</span>
                    <span className="metric-value">${sentimentData.analysts.avgPriceTarget} ({sentimentData.analysts.upside > 0 ? '+' : ''}{sentimentData.analysts.upside}%)</span>
                  </div>
                </div>

                {/* News */}
                <div className="card" style={{ marginBottom: 16 }}>
                  <div className="card-header">
                    <span className="card-title">News Sentiment</span>
                    <span style={{ color: sentimentData.news.overallScore > 0 ? 'var(--accent-green)' : 'var(--accent-red)', fontSize: 13, fontWeight: 600 }}>
                      {sentimentData.news.sentiment} ({sentimentData.news.overallScore > 0 ? '+' : ''}{sentimentData.news.overallScore})
                    </span>
                  </div>
                  <div className="scrollable" style={{ maxHeight: 250 }}>
                    {sentimentData.news.articles.map((article, idx) => (
                      <div key={idx} className="news-item">
                        <div>{article.headline}</div>
                        <div className="news-meta">
                          <span className="news-sentiment-tag" style={{
                            background: article.sentiment === 'positive' ? 'rgba(16,185,129,0.15)' :
                                        article.sentiment === 'negative' ? 'rgba(239,68,68,0.15)' : 'rgba(245,158,11,0.15)',
                            color: article.sentiment === 'positive' ? 'var(--accent-green)' :
                                   article.sentiment === 'negative' ? 'var(--accent-red)' : 'var(--accent-yellow)'
                          }}>
                            {article.sentiment}
                          </span>
                          <span>{article.source}</span>
                          <span>{article.timeAgo}</span>
                          <span className="mono">Score: {article.score}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Social */}
                <div className="card">
                  <div className="card-header">
                    <span className="card-title">Social Media Buzz</span>
                    <span style={{ color: 'var(--text-muted)', fontSize: 12 }}>
                      {sentimentData.social.mentions.toLocaleString()} mentions
                    </span>
                  </div>
                  <div className="sentiment-bar-container">
                    <div className="sentiment-bar-label">
                      <span style={{ color: 'var(--accent-green)' }}>Bullish {sentimentData.social.bullishPercent}%</span>
                      <span style={{ color: 'var(--accent-red)' }}>{sentimentData.social.bearishPercent}% Bearish</span>
                    </div>
                    <div style={{ display: 'flex', height: 20, borderRadius: 4, overflow: 'hidden' }}>
                      <div style={{ width: `${sentimentData.social.bullishPercent}%`, background: 'var(--accent-green)' }} />
                      <div style={{ width: `${sentimentData.social.neutralPercent}%`, background: 'var(--accent-yellow)' }} />
                      <div style={{ width: `${sentimentData.social.bearishPercent}%`, background: 'var(--accent-red)' }} />
                    </div>
                  </div>
                  <div style={{ marginTop: 8, fontSize: 12, color: 'var(--text-muted)' }}>
                    Trending: {sentimentData.social.trendingKeywords.map((kw, i) => (
                      <span key={i} style={{
                        display: 'inline-block', margin: '2px 4px', padding: '2px 8px',
                        background: 'var(--bg-secondary)', borderRadius: 4, fontSize: 11
                      }}>{kw}</span>
                    ))}
                  </div>
                  <div className="metric-row" style={{ marginTop: 8 }}>
                    <span className="metric-label">Momentum</span>
                    <span className="metric-value">{sentimentData.social.momentum}</span>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      );

      // ─── Backtest Tab ──────────────────────────────
      const renderBacktest = () => (
        <div>
          <div className="explainer">
            <strong>Backtesting</strong> runs the ORB strategy against historical data to see how it would have performed.
            Configure the ticker, date range, and strategy parameters below, then click <em>Run Backtest</em>.
            Results include an equity curve, drawdown chart, per-trade breakdown, and a Monte Carlo simulation
            that shuffles trade order 1,000 times to check if the results are statistically robust.
          </div>
          {/* Config */}
          <div className="card mb-16" style={{ marginBottom: 16 }}>
            <div className="card-header">
              <span className="card-title">Backtest Configuration</span>
              <div className="btn-group">
                <button className="btn btn-primary" onClick={runBacktest} disabled={backtestRunning}>
                  {backtestRunning ? <><span className="spinner" style={{ marginRight: 8 }} /> Running...</> : 'Run Backtest'}
                </button>
              </div>
            </div>
            <div className="config-grid">
              <div className="config-field">
                <label>Ticker</label>
                <select value={btConfig.ticker} onChange={e => setBtConfig({ ...btConfig, ticker: e.target.value })}>
                  {ALL_TICKERS.map(t => <option key={t} value={t}>{t} - {MarketData.STOCK_PROFILES[t].name}</option>)}
                </select>
              </div>
              <div className="config-field">
                <label>Start Date</label>
                <input type="date" value={btConfig.startDate}
                  onChange={e => setBtConfig({ ...btConfig, startDate: e.target.value })} />
              </div>
              <div className="config-field">
                <label>Trading Days</label>
                <input type="number" value={btConfig.numDays}
                  onChange={e => setBtConfig({ ...btConfig, numDays: Number(e.target.value) })} />
              </div>
              <div className="config-field">
                <label>Starting Capital ($)</label>
                <input type="number" value={btConfig.startingCapital}
                  onChange={e => setBtConfig({ ...btConfig, startingCapital: Number(e.target.value) })} />
              </div>
              <div className="config-field">
                <label>Opening Range (min)</label>
                <select value={stratConfig.openingRangeMinutes}
                  onChange={e => setStratConfig({ ...stratConfig, openingRangeMinutes: Number(e.target.value) })}>
                  <option value={5}>5 minutes</option>
                  <option value={15}>15 minutes</option>
                  <option value={30}>30 minutes</option>
                </select>
              </div>
              <div className="config-field">
                <label>Confirmation</label>
                <select value={stratConfig.confirmationType}
                  onChange={e => setStratConfig({ ...stratConfig, confirmationType: e.target.value })}>
                  <option value="close">Candle Close</option>
                  <option value="wick">Wick Breach</option>
                </select>
              </div>
              <div className="config-field">
                <label>Volume Confirmation</label>
                <select value={stratConfig.volumeConfirmation.toString()}
                  onChange={e => setStratConfig({ ...stratConfig, volumeConfirmation: e.target.value === 'true' })}>
                  <option value="true">Enabled</option>
                  <option value="false">Disabled</option>
                </select>
              </div>
              <div className="config-field">
                <label>VWAP Confirmation</label>
                <select value={stratConfig.vwapConfirmation.toString()}
                  onChange={e => setStratConfig({ ...stratConfig, vwapConfirmation: e.target.value === 'true' })}>
                  <option value="true">Enabled</option>
                  <option value="false">Disabled</option>
                </select>
              </div>
              <div className="config-field">
                <label>Sentiment Confirmation</label>
                <select value={stratConfig.sentimentConfirmation.toString()}
                  onChange={e => setStratConfig({ ...stratConfig, sentimentConfirmation: e.target.value === 'true' })}>
                  <option value="true">Enabled</option>
                  <option value="false">Disabled</option>
                </select>
              </div>
              <div className="config-field">
                <label>Min Confirmations</label>
                <select value={stratConfig.minConfirmations}
                  onChange={e => setStratConfig({ ...stratConfig, minConfirmations: Number(e.target.value) })}>
                  <option value={1}>1 of 3</option>
                  <option value={2}>2 of 3</option>
                  <option value={3}>3 of 3</option>
                </select>
              </div>
              <div className="config-field">
                <label>Risk Per Trade (%)</label>
                <input type="number" step="0.5" value={stratConfig.riskPerTrade * 100}
                  onChange={e => setStratConfig({ ...stratConfig, riskPerTrade: Number(e.target.value) / 100 })} />
              </div>
              <div className="config-field">
                <label>Max Trades / Day</label>
                <input type="number" value={stratConfig.maxTradesPerDay}
                  onChange={e => setStratConfig({ ...stratConfig, maxTradesPerDay: Number(e.target.value) })} />
              </div>
            </div>
          </div>

          {/* Results */}
          {backtestResult && (
            <>
              {/* Key Metrics */}
              <div className="grid-4 mb-16" style={{ marginBottom: 16 }}>
                <div className="stat-box">
                  <div className={`stat-value ${backtestResult.metrics.totalPnL >= 0 ? 'positive' : 'negative'}`}>
                    ${backtestResult.metrics.totalPnL.toLocaleString()}
                  </div>
                  <div className="stat-label">Net P&L</div>
                </div>
                <div className="stat-box">
                  <div className={`stat-value ${backtestResult.metrics.totalReturn >= 0 ? 'positive' : 'negative'}`}>
                    {backtestResult.metrics.totalReturn}%
                  </div>
                  <div className="stat-label">Total Return</div>
                </div>
                <div className="stat-box">
                  <div className="stat-value" style={{ color: backtestResult.metrics.winRate > 50 ? 'var(--accent-green)' : 'var(--accent-yellow)' }}>
                    {backtestResult.metrics.winRate}%
                  </div>
                  <div className="stat-label">Win Rate</div>
                </div>
                <div className="stat-box">
                  <div className="stat-value negative">
                    -{backtestResult.metrics.maxDrawdownPct}%
                  </div>
                  <div className="stat-label">Max Drawdown</div>
                </div>
              </div>

              <div className="grid-2 mb-16" style={{ marginBottom: 16 }}>
                {/* Equity Curve */}
                <div className="card">
                  <div className="card-header">
                    <span className="card-title">Equity Curve</span>
                  </div>
                  <LineChart
                    data={backtestResult.equityCurve.map(e => e.equity)}
                    height={300}
                    color="#3b82f6"
                    fillColor="rgba(59,130,246,0.15)"
                    yFormat={v => '$' + v.toFixed(0)}
                    title={`${btConfig.ticker} - ${btConfig.numDays} Day Backtest`}
                  />
                </div>

                {/* Drawdown */}
                <div className="card">
                  <div className="card-header">
                    <span className="card-title">Drawdown</span>
                  </div>
                  <LineChart
                    data={backtestResult.equityCurve.map(e => -(e.drawdownPct || 0))}
                    height={300}
                    color="#ef4444"
                    fillColor="rgba(239,68,68,0.15)"
                    yFormat={v => v.toFixed(1) + '%'}
                    title="Underwater Curve"
                  />
                </div>
              </div>

              <div className="grid-2 mb-16" style={{ marginBottom: 16 }}>
                {/* Daily P&L */}
                <div className="card">
                  <div className="card-header">
                    <span className="card-title">Daily P&L Distribution</span>
                  </div>
                  <BarChart
                    data={backtestResult.equityCurve.slice(1).map(e => e.pnl)}
                    height={250}
                    title="Daily P&L ($)"
                  />
                </div>

                {/* Detailed metrics */}
                <div className="card">
                  <div className="card-header">
                    <span className="card-title">Performance Metrics</span>
                  </div>
                  <div className="scrollable">
                    <div className="metric-row">
                      <span className="metric-label">Total Trades</span>
                      <span className="metric-value">{backtestResult.metrics.totalTrades}</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Winners / Losers</span>
                      <span className="metric-value">{backtestResult.metrics.winners}W / {backtestResult.metrics.losers}L</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Win Rate <span className="metric-hint">(% of profitable trades)</span></span>
                      <span className="metric-value">{backtestResult.metrics.winRate}%</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Profit Factor <span className="metric-hint">(gross wins / gross losses; {">"} 1 = profitable)</span></span>
                      <span className="metric-value">{backtestResult.metrics.profitFactor}</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Expectancy <span className="metric-hint">(avg $ per trade)</span></span>
                      <span className={`metric-value ${backtestResult.metrics.expectancy >= 0 ? 'positive' : 'negative'}`}>
                        ${backtestResult.metrics.expectancy}
                      </span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Avg Win</span>
                      <span className="metric-value positive">${backtestResult.metrics.avgWin}</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Avg Loss</span>
                      <span className="metric-value negative">-${backtestResult.metrics.avgLoss}</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Win/Loss Ratio <span className="metric-hint">(avg win size / avg loss size)</span></span>
                      <span className="metric-value">{backtestResult.metrics.avgWinLossRatio}x</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Largest Win</span>
                      <span className="metric-value positive">${backtestResult.metrics.largestWin}</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Largest Loss</span>
                      <span className="metric-value negative">${backtestResult.metrics.largestLoss}</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Max Consecutive Wins</span>
                      <span className="metric-value">{backtestResult.metrics.maxConsecWins}</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Max Consecutive Losses</span>
                      <span className="metric-value">{backtestResult.metrics.maxConsecLosses}</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Sharpe Ratio <span className="metric-hint">(return per unit of risk; {">"} 1 is good)</span></span>
                      <span className="metric-value">{backtestResult.metrics.sharpeRatio}</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Sortino Ratio <span className="metric-hint">(like Sharpe but only counts downside risk)</span></span>
                      <span className="metric-value">{backtestResult.metrics.sortinoRatio}</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Avg Trade Duration</span>
                      <span className="metric-value">{backtestResult.metrics.avgDuration} min</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Long / Short Trades</span>
                      <span className="metric-value">{backtestResult.metrics.longTrades}L / {backtestResult.metrics.shortTrades}S</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Long Win Rate</span>
                      <span className="metric-value">{backtestResult.metrics.longWinRate}%</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Short Win Rate</span>
                      <span className="metric-value">{backtestResult.metrics.shortWinRate}%</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Max Drawdown <span className="metric-hint">(largest peak-to-trough decline)</span></span>
                      <span className="metric-value negative">${backtestResult.metrics.maxDrawdown}</span>
                    </div>
                    <div className="metric-row">
                      <span className="metric-label">Final Equity</span>
                      <span className={`metric-value ${backtestResult.metrics.finalEquity >= btConfig.startingCapital ? 'positive' : 'negative'}`}>
                        ${backtestResult.metrics.finalEquity.toLocaleString()}
                      </span>
                    </div>
                  </div>
                </div>
              </div>

              {/* Monte Carlo */}
              {backtestResult.monteCarlo && (
                <div className="card mb-16" style={{ marginBottom: 16 }}>
                  <div className="card-header">
                    <span className="card-title">Monte Carlo Simulation (1,000 runs)</span>
                    <span style={{ color: 'var(--text-muted)', fontSize: 12 }}>Trade resampling with replacement</span>
                  </div>
                  <div className="explainer" style={{ marginBottom: 16 }}>
                    The Monte Carlo simulation takes the same set of trades and <strong>randomly reshuffles their order 1,000 times</strong>.
                    This shows the range of outcomes you could expect if the trades happened in a different sequence.
                    A wide spread between the 5th and 95th percentile means results are sensitive to luck; a narrow spread means the strategy is more robust.
                  </div>
                  <div className="grid-4">
                    <div className="stat-box">
                      <div className="stat-value negative">${backtestResult.monteCarlo.percentile5.finalEquity.toLocaleString()}</div>
                      <div className="stat-label">5th Percentile</div>
                    </div>
                    <div className="stat-box">
                      <div className="stat-value neutral">${backtestResult.monteCarlo.percentile25.finalEquity.toLocaleString()}</div>
                      <div className="stat-label">25th Percentile</div>
                    </div>
                    <div className="stat-box">
                      <div className="stat-value" style={{ color: 'var(--accent-blue)' }}>${backtestResult.monteCarlo.median.finalEquity.toLocaleString()}</div>
                      <div className="stat-label">Median</div>
                    </div>
                    <div className="stat-box">
                      <div className="stat-value positive">${backtestResult.monteCarlo.percentile95.finalEquity.toLocaleString()}</div>
                      <div className="stat-label">95th Percentile</div>
                    </div>
                  </div>
                </div>
              )}

              {/* Trade List */}
              <div className="card">
                <div className="card-header">
                  <span className="card-title">All Trades</span>
                  <span className="card-badge" style={{ background: 'rgba(59,130,246,0.15)', color: 'var(--accent-blue)' }}>
                    {backtestResult.trades.length} trades
                  </span>
                </div>
                <div className="scrollable" style={{ maxHeight: 500 }}>
                  <table className="trade-table">
                    <thead>
                      <tr>
                        <th>Day</th>
                        <th>Date</th>
                        <th>Dir</th>
                        <th>Entry</th>
                        <th>Shares</th>
                        <th>Gross P&L</th>
                        <th>Net P&L</th>
                        <th>Return</th>
                        <th>Duration</th>
                        <th>Exit Reason</th>
                      </tr>
                    </thead>
                    <tbody>
                      {backtestResult.trades.map((trade, idx) => (
                        <tr key={idx}>
                          <td>{trade.day}</td>
                          <td>{trade.date}</td>
                          <td><span className={trade.direction === 'LONG' ? 'dir-long' : 'dir-short'}>{trade.direction}</span></td>
                          <td>${trade.entryPrice.toFixed(2)}</td>
                          <td>{trade.shares}</td>
                          <td className={trade.grossPnL >= 0 ? 'pnl-positive' : 'pnl-negative'}>${trade.grossPnL.toFixed(2)}</td>
                          <td className={trade.netPnL >= 0 ? 'pnl-positive' : 'pnl-negative'}>${trade.netPnL.toFixed(2)}</td>
                          <td className={trade.returnPct >= 0 ? 'pnl-positive' : 'pnl-negative'}>{trade.returnPct}%</td>
                          <td>{trade.durationMinutes}m</td>
                          <td style={{ color: 'var(--text-muted)', fontFamily: 'Inter, sans-serif' }}>{trade.exitReason}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            </>
          )}

          {!backtestResult && !backtestRunning && (
            <div className="card" style={{ textAlign: 'center', padding: 60 }}>
              <div style={{ fontSize: 48, marginBottom: 16, opacity: 0.3 }}>&#9654;</div>
              <div style={{ color: 'var(--text-muted)', fontSize: 14, maxWidth: 500, margin: '0 auto', lineHeight: 1.7 }}>
                Configure the ticker, date range, and ORB strategy parameters above, then click <strong style={{ color: 'var(--text-primary)' }}>"Run Backtest"</strong> to
                simulate how the strategy would have performed. You'll see an equity curve, drawdown chart, per-trade breakdown,
                and a Monte Carlo analysis.
              </div>
            </div>
          )}
        </div>
      );

      // ─── Strategy Config Tab ──────────────────────────────
      const renderStrategy = () => (
        <div>
          <div className="explainer">
            <strong>Opening Range Breakout (ORB)</strong> identifies the price range from the first N minutes of trading,
            then enters trades when price breaks out. Adjust parameters below to tune aggressiveness, risk, and profit targets.
            Changes apply immediately to the Backtest simulation.
            Visit the <em>Learn</em> tab for full background on why this strategy works.
          </div>
          <div className="grid-2">
            <div className="card">
              <div className="card-header">
                <span className="card-title">ORB Strategy Parameters</span>
              </div>
              <div style={{ marginBottom: 16, padding: 12, background: 'var(--bg-secondary)', borderRadius: 8, fontSize: 13, color: 'var(--text-secondary)', lineHeight: 1.6 }}>
                The <strong style={{ color: 'var(--accent-blue)' }}>Opening Range Breakout (ORB)</strong> strategy watches the first
                N minutes of trading to establish a price range, then enters trades when price decisively breaks out.
                <strong>Long</strong> entries trigger on breakouts above the range high; <strong>short</strong> entries on breakdowns below the range low.
                Stop losses are placed at the opposite end of the range. The range size sets natural profit targets.
                Use <strong>volume, VWAP, and sentiment confirmations</strong> to filter trades and improve win rate.
              </div>
              <div className="config-grid">
                <div className="config-field">
                  <label>Opening Range Period</label>
                  <select value={stratConfig.openingRangeMinutes}
                    onChange={e => setStratConfig({ ...stratConfig, openingRangeMinutes: Number(e.target.value) })}>
                    <option value={5}>5 minutes (Aggressive)</option>
                    <option value={15}>15 minutes (Standard)</option>
                    <option value={30}>30 minutes (Conservative)</option>
                  </select>
                </div>
                <div className="config-field">
                  <label>Breakout Confirmation</label>
                  <select value={stratConfig.confirmationType}
                    onChange={e => setStratConfig({ ...stratConfig, confirmationType: e.target.value })}>
                    <option value="close">Candle Close (Safer)</option>
                    <option value="wick">Wick Breach (Faster)</option>
                  </select>
                </div>
                <div className="config-field">
                  <label>Volume Confirmation</label>
                  <select value={stratConfig.volumeConfirmation.toString()}
                    onChange={e => setStratConfig({ ...stratConfig, volumeConfirmation: e.target.value === 'true' })}>
                    <option value="true">Enabled</option>
                    <option value="false">Disabled</option>
                  </select>
                </div>
                <div className="config-field">
                  <label>Volume Multiplier</label>
                  <input type="number" step="0.1" value={stratConfig.volumeMultiplier}
                    onChange={e => setStratConfig({ ...stratConfig, volumeMultiplier: Number(e.target.value) })} />
                </div>
                <div className="config-field">
                  <label>VWAP Confirmation</label>
                  <select value={stratConfig.vwapConfirmation.toString()}
                    onChange={e => setStratConfig({ ...stratConfig, vwapConfirmation: e.target.value === 'true' })}>
                    <option value="true">Enabled</option>
                    <option value="false">Disabled</option>
                  </select>
                </div>
                <div className="config-field">
                  <label>Sentiment Confirmation</label>
                  <select value={stratConfig.sentimentConfirmation.toString()}
                    onChange={e => setStratConfig({ ...stratConfig, sentimentConfirmation: e.target.value === 'true' })}>
                    <option value="true">Enabled</option>
                    <option value="false">Disabled</option>
                  </select>
                </div>
                <div className="config-field">
                  <label>Min Confirmations</label>
                  <select value={stratConfig.minConfirmations}
                    onChange={e => setStratConfig({ ...stratConfig, minConfirmations: Number(e.target.value) })}>
                    <option value={1}>1 of 3</option>
                    <option value={2}>2 of 3</option>
                    <option value={3}>3 of 3</option>
                  </select>
                </div>
                <div className="config-field">
                  <label>Risk Per Trade (%)</label>
                  <input type="number" step="0.5" value={stratConfig.riskPerTrade * 100}
                    onChange={e => setStratConfig({ ...stratConfig, riskPerTrade: Number(e.target.value) / 100 })} />
                </div>
                <div className="config-field">
                  <label>Max Trades / Day</label>
                  <input type="number" min="1" max="5" value={stratConfig.maxTradesPerDay}
                    onChange={e => setStratConfig({ ...stratConfig, maxTradesPerDay: Number(e.target.value) })} />
                </div>
                <div className="config-field">
                  <label>Trailing Stop</label>
                  <select value={stratConfig.trailingStop.toString()}
                    onChange={e => setStratConfig({ ...stratConfig, trailingStop: e.target.value === 'true' })}>
                    <option value="true">Enabled</option>
                    <option value="false">Disabled</option>
                  </select>
                </div>
                <div className="config-field">
                  <label>Break-Even After T1</label>
                  <select value={stratConfig.breakEvenAfterTarget1.toString()}
                    onChange={e => setStratConfig({ ...stratConfig, breakEvenAfterTarget1: e.target.value === 'true' })}>
                    <option value="true">Enabled</option>
                    <option value="false">Disabled</option>
                  </select>
                </div>
              </div>
            </div>

            <div className="card">
              <div className="card-header">
                <span className="card-title">Strategy Rules</span>
              </div>
              <div style={{ fontSize: 13, lineHeight: 2, color: 'var(--text-secondary)' }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <span style={{ color: 'var(--accent-blue)', fontWeight: 600, width: 20 }}>1.</span>
                  <span>Wait for the first <strong style={{ color: 'var(--text-primary)' }}>{stratConfig.openingRangeMinutes} minutes</strong> to establish the Opening Range</span>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <span style={{ color: 'var(--accent-blue)', fontWeight: 600, width: 20 }}>2.</span>
                  <span>Identify the <strong style={{ color: 'var(--accent-green)' }}>range high</strong> and <strong style={{ color: 'var(--accent-red)' }}>range low</strong></span>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <span style={{ color: 'var(--accent-blue)', fontWeight: 600, width: 20 }}>3.</span>
                  <span>Enter <strong style={{ color: 'var(--accent-green)' }}>LONG</strong> on breakout above range high ({stratConfig.confirmationType === 'close' ? 'candle close' : 'wick breach'})</span>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <span style={{ color: 'var(--accent-blue)', fontWeight: 600, width: 20 }}>4.</span>
                  <span>Enter <strong style={{ color: 'var(--accent-red)' }}>SHORT</strong> on breakdown below range low ({stratConfig.confirmationType === 'close' ? 'candle close' : 'wick breach'})</span>
                </div>
                {(stratConfig.volumeConfirmation || stratConfig.vwapConfirmation || stratConfig.sentimentConfirmation) && (
                  <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                    <span style={{ color: 'var(--accent-blue)', fontWeight: 600, width: 20 }}>5.</span>
                    <span>Require <strong style={{ color: 'var(--text-primary)' }}>{stratConfig.minConfirmations} of 3</strong> confirmations: 
                      {stratConfig.volumeConfirmation && <> volume ({stratConfig.volumeMultiplier}x)</>}
                      {stratConfig.vwapConfirmation && <>, VWAP alignment</>}
                      {stratConfig.sentimentConfirmation && <>, sentiment alignment</>}
                    </span>
                  </div>
                )}
                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <span style={{ color: 'var(--accent-blue)', fontWeight: 600, width: 20 }}>{(stratConfig.volumeConfirmation || stratConfig.vwapConfirmation || stratConfig.sentimentConfirmation) ? '6' : '5'}.</span>
                  <span>Stop loss at opposite end of range (risk: <strong style={{ color: 'var(--accent-yellow)' }}>{stratConfig.riskPerTrade * 100}%</strong> of account)</span>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <span style={{ color: 'var(--accent-blue)', fontWeight: 600, width: 20 }}>{(stratConfig.volumeConfirmation || stratConfig.vwapConfirmation || stratConfig.sentimentConfirmation) ? '7' : '6'}.</span>
                  <span>Take profits at <strong style={{ color: 'var(--text-primary)' }}>1.5x, 2x, 3x</strong> range size (scale out)</span>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <span style={{ color: 'var(--accent-blue)', fontWeight: 600, width: 20 }}>{(stratConfig.volumeConfirmation || stratConfig.vwapConfirmation || stratConfig.sentimentConfirmation) ? '8' : '7'}.</span>
                  <span>Max <strong style={{ color: 'var(--text-primary)' }}>{stratConfig.maxTradesPerDay}</strong> trades per day</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      );

      // ─── Learn Tab ──────────────────────────────
      const renderLearn = () => (
        <div>
          <div className="card mb-16" style={{ marginBottom: 16 }}>
            <div className="learn-section">
              <h2>What Is the Opening Range?</h2>
              <p>
                The <strong>opening range</strong> is the price range established during the first few minutes of the regular
                trading session (9:30 AM ET for U.S. equities). Traders typically use the first <strong>5, 15, or 30 minutes</strong> to
                define this range. The highest price reached during that window becomes the <strong>opening range high</strong>,
                and the lowest price becomes the <strong>opening range low</strong>.
              </p>
              <p style={{ marginTop: 8 }}>
                This narrow window captures the initial battle between buyers and sellers as overnight orders, pre-market
                sentiment, and institutional positioning collide at the open. The resulting high and low act as key reference
                levels for the rest of the day.
              </p>
            </div>
          </div>

          <div className="card mb-16" style={{ marginBottom: 16 }}>
            <div className="learn-section">
              <h2>The Core Idea</h2>
              <p>
                The Opening Range Breakout strategy is built on a simple premise: <strong>when price decisively moves beyond
                the opening range, it tends to continue in that direction.</strong>
              </p>
              <div className="grid-2" style={{ marginTop: 16 }}>
                <div className="learn-grid-item" style={{ borderLeft: '3px solid var(--accent-green)' }}>
                  <h4 style={{ color: 'var(--accent-green)' }}>Breakout Above = Go Long</h4>
                  <p>When price closes above the opening range high, it signals bullish momentum. The strategy enters a long position, expecting the move to continue upward.</p>
                </div>
                <div className="learn-grid-item" style={{ borderLeft: '3px solid var(--accent-red)' }}>
                  <h4 style={{ color: 'var(--accent-red)' }}>Breakdown Below = Go Short</h4>
                  <p>When price closes below the opening range low, it signals bearish momentum. The strategy enters a short position, expecting the move to continue downward.</p>
                </div>
              </div>
              <p style={{ marginTop: 12 }}>
                The opening range itself provides natural levels for stop losses and profit targets, giving the strategy a built-in risk/reward framework.
              </p>
            </div>
          </div>

          <div className="card mb-16" style={{ marginBottom: 16 }}>
            <div className="learn-section">
              <h2>Why It Works</h2>
              <p>The ORB strategy has been used by professional day traders for decades. Its edge comes from several market dynamics:</p>
              <div className="grid-2" style={{ marginTop: 16, gap: 12 }}>
                <div className="learn-grid-item">
                  <div className="number">01</div>
                  <h4>Institutional Order Flow</h4>
                  <p>Large funds often execute significant positions in the first 15-30 minutes. When price escapes the range created by this activity, it suggests directional conviction.</p>
                </div>
                <div className="learn-grid-item">
                  <div className="number">02</div>
                  <h4>Liquidity Concentration</h4>
                  <p>The open is the most liquid period of the day. Breakouts from this high-liquidity zone carry more significance than breakouts during quieter hours.</p>
                </div>
                <div className="learn-grid-item">
                  <div className="number">03</div>
                  <h4>Overnight Gap Resolution</h4>
                  <p>Stocks that gap up or down at the open often establish a range while the market digests the move. A breakout from this range signals whether the gap will be "filled" (reversed) or "extended" (continued).</p>
                </div>
                <div className="learn-grid-item">
                  <div className="number">04</div>
                  <h4>Self-Fulfilling Behavior</h4>
                  <p>Many traders watch the same opening range levels. When price breaks through, the collective response (entries, stops triggering, short covering) accelerates the move.</p>
                </div>
              </div>
            </div>
          </div>

          <div className="grid-2 mb-16" style={{ marginBottom: 16 }}>
            <div className="card">
              <div className="learn-section">
                <h2>How This App Works</h2>
                <h3>Entry Rules</h3>
                <ul>
                  <li>Wait for the opening range to form (configurable: 5, 15, or 30 minutes)</li>
                  <li><strong>Long entry:</strong> Price closes above the opening range high (or wicks above, depending on confirmation setting)</li>
                  <li><strong>Short entry:</strong> Price closes below the opening range low</li>
                  <li><strong>Volume confirmation:</strong> Breakout candle volume must exceed 1.5x the average volume during the opening range (optional)</li>
                  <li><strong>VWAP confirmation:</strong> For long trades, price must be above VWAP; for short trades, below VWAP (optional)</li>
                  <li><strong>Sentiment confirmation:</strong> For long trades, sentiment score must be positive; for short trades, negative (optional)</li>
                  <li><strong>Minimum confirmations:</strong> Require 1, 2, or 3 of the above confirmations to be met before entering a trade</li>
                </ul>
                <h3>Risk Management</h3>
                <ul>
                  <li><strong>Stop loss:</strong> Placed at the opposite side of the opening range, plus a small buffer</li>
                  <li><strong>Position sizing:</strong> Based on fixed-risk model &mdash; risk 2% of account per trade</li>
                  <li><strong>Max trades:</strong> Limited to 2 trades per day to avoid overtrading</li>
                </ul>
                <h3>Profit Taking</h3>
                <ul>
                  <li><strong>Partial exits</strong> at 1.5x, 2.0x, and 3.0x the range size (~33% at each level)</li>
                  <li><strong>Break-even stop:</strong> After the first target is hit, the stop moves to the entry price</li>
                  <li><strong>Trailing stop:</strong> Optional &mdash; activates after 1x range profit, trails by 0.5x range</li>
                  <li><strong>End-of-day close:</strong> All positions closed before market close (no overnight risk)</li>
                </ul>
              </div>
            </div>

            <div className="card">
              <div className="learn-section">
                <h2>Key Metrics Explained</h2>
                <div className="metric-row">
                  <span className="metric-label"><strong>Win Rate</strong></span>
                  <span className="metric-hint">% of trades that are profitable</span>
                </div>
                <div className="metric-row">
                  <span className="metric-label"><strong>Profit Factor</strong></span>
                  <span className="metric-hint">Gross profits / gross losses ({">"} 1.0 is profitable)</span>
                </div>
                <div className="metric-row">
                  <span className="metric-label"><strong>Sharpe Ratio</strong></span>
                  <span className="metric-hint">Risk-adjusted return (higher = better reward per unit of risk)</span>
                </div>
                <div className="metric-row">
                  <span className="metric-label"><strong>Sortino Ratio</strong></span>
                  <span className="metric-hint">Like Sharpe, but only penalizes downside volatility</span>
                </div>
                <div className="metric-row">
                  <span className="metric-label"><strong>Max Drawdown</strong></span>
                  <span className="metric-hint">Largest peak-to-trough decline in account equity</span>
                </div>
                <div className="metric-row">
                  <span className="metric-label"><strong>Expectancy</strong></span>
                  <span className="metric-hint">Average $ won or lost per trade</span>
                </div>
                <div className="metric-row">
                  <span className="metric-label"><strong>MFE / MAE</strong></span>
                  <span className="metric-hint">Max Favorable / Adverse Excursion &mdash; how far trades move for and against you</span>
                </div>
                <div className="metric-row">
                  <span className="metric-label"><strong>Monte Carlo</strong></span>
                  <span className="metric-hint">Shuffles trade sequence 1,000x to test if results are robust or order-dependent</span>
                </div>
              </div>
              <div className="learn-section" style={{ marginTop: 16 }}>
                <h2>Best Practices</h2>
                <ul>
                  <li><strong>Trade liquid instruments</strong> &mdash; ORB works best on stocks and ETFs with tight spreads and high volume (SPY, QQQ, AAPL, etc.)</li>
                  <li><strong>Respect the range size</strong> &mdash; Very narrow ranges often produce larger breakouts; very wide ranges may lack a clear edge</li>
                  <li><strong>Avoid major news events</strong> &mdash; FOMC days, CPI releases, and earnings can produce false breakouts</li>
                  <li><strong>Use the sentiment filter</strong> &mdash; Aligning breakout direction with pre-market sentiment improves follow-through probability</li>
                  <li><strong>Keep it mechanical</strong> &mdash; The strategy's strength is its objectivity; discretionary overrides often degrade performance</li>
                </ul>
              </div>
            </div>
          </div>

          <div className="card">
            <div className="learn-section">
              <h2>History</h2>
              <p>
                The ORB concept was popularized by <strong>Toby Crabel</strong> in his 1990 book
                <em> Day Trading with Short Term Price Patterns and Opening Range Breakout</em>. Crabel studied how narrow opening
                ranges often preceded large intraday moves, and developed systematic rules for trading these patterns.
              </p>
              <p style={{ marginTop: 8 }}>
                <strong>Mark Fisher</strong> expanded on the concept with his ACD Trading Method, adding statistical "pivot range"
                filters to improve signal quality. His approach, documented in <em>The Logical Trader</em> (2002), is still used
                by commodity and equity traders today.
              </p>
              <h3>Further Reading</h3>
              <ul>
                <li>Toby Crabel &mdash; <em>Day Trading with Short Term Price Patterns and Opening Range Breakout</em> (1990)</li>
                <li>Mark Fisher &mdash; <em>The Logical Trader</em> (2002)</li>
                <li>Linda Raschke & Larry Connors &mdash; <em>Street Smarts</em> (1995), Chapter on Opening Range Breakouts</li>
              </ul>
            </div>
          </div>
        </div>
      );

      // ─── Admin Tab ──────────────────────────────
      const clearAllCaches = async () => {
        setCacheStatus('Clearing...');
        try {
          const keys = await caches.keys();
          await Promise.all(keys.map(k => caches.delete(k)));
          if ('serviceWorker' in navigator) {
            const reg = await navigator.serviceWorker.getRegistration();
            if (reg) { await reg.unregister(); }
          }
          setCacheStatus(`Cleared ${keys.length} cache(s) and unregistered service worker. Reload to re-register.`);
        } catch (e) {
          setCacheStatus('Error: ' + e.message);
        }
      };

      const checkSwStatus = async () => {
        if (!('serviceWorker' in navigator)) { setSwStatus('Service Workers not supported'); return; }
        try {
          const reg = await navigator.serviceWorker.getRegistration();
          if (!reg) { setSwStatus('No service worker registered'); return; }
          const sw = reg.active || reg.waiting || reg.installing;
          const cacheKeys = await caches.keys();
          setSwStatus(`State: ${sw ? sw.state : 'none'} | Scope: ${reg.scope} | Caches: ${cacheKeys.join(', ') || 'none'}`);
        } catch (e) { setSwStatus('Error: ' + e.message); }
      };

      const logColors = { log: 'var(--text-secondary)', info: 'var(--accent-blue)', warn: 'var(--accent-yellow)', error: 'var(--accent-red)' };

      const renderAdmin = () => (
        <div>
          <div className="explainer">
            <strong>Admin / Dev Tools</strong> — View console logs in-app, clear caches, and inspect service worker state.
            Useful when debugging on mobile or verifying deployments.
          </div>

          {/* App Info */}
          <div className="card mb-16" style={{ marginBottom: 16 }}>
            <div className="card-header">
              <span className="card-title">App Info</span>
            </div>
            <div className="metric-row">
              <span className="metric-label">Version</span>
              <span className="metric-value">v{APP_VERSION}</span>
            </div>
            <div className="metric-row">
              <span className="metric-label">User Agent</span>
              <span className="metric-value" style={{ fontSize: 11, maxWidth: '70%', textAlign: 'right', wordBreak: 'break-word' }}>{navigator.userAgent}</span>
            </div>
            <div className="metric-row">
              <span className="metric-label">Page Loaded</span>
              <span className="metric-value">{new Date().toLocaleString()}</span>
            </div>
            <div className="metric-row">
              <span className="metric-label">Protocol</span>
              <span className="metric-value">{location.protocol + '//' + location.host}</span>
            </div>
          </div>

          {/* Cache & Service Worker */}
          <div className="card mb-16" style={{ marginBottom: 16 }}>
            <div className="card-header">
              <span className="card-title">Cache & Service Worker</span>
            </div>
            <div className="btn-group" style={{ marginBottom: 12 }}>
              <button className="btn btn-danger" onClick={clearAllCaches}>Clear All Caches & Unregister SW</button>
              <button className="btn btn-outline" onClick={checkSwStatus}>Check SW Status</button>
              <button className="btn btn-outline" onClick={() => location.reload()}>Hard Reload</button>
            </div>
            {cacheStatus && (
              <div style={{ padding: '8px 12px', background: 'rgba(16,185,129,0.08)', borderRadius: 6, fontSize: 12, color: 'var(--accent-green)', marginBottom: 8 }}>
                {cacheStatus}
              </div>
            )}
            {swStatus && (
              <div style={{ padding: '8px 12px', background: 'rgba(59,130,246,0.08)', borderRadius: 6, fontSize: 12, color: 'var(--accent-blue)', fontFamily: "'JetBrains Mono', monospace" }}>
                {swStatus}
              </div>
            )}
          </div>

          {/* Console Logs */}
          <div className="card">
            <div className="card-header">
              <span className="card-title">Console Logs</span>
              <div className="btn-group">
                <span className="card-badge" style={{ background: 'rgba(59,130,246,0.15)', color: 'var(--accent-blue)' }}>
                  {logs.length} entries
                </span>
                <button className="btn btn-outline" style={{ padding: '4px 12px', fontSize: 11 }}
                  onClick={() => setLogs([])}>
                  Clear
                </button>
              </div>
            </div>
            <div style={{
              background: 'var(--bg-primary)', borderRadius: 8, padding: 8,
              maxHeight: 500, overflowY: 'auto', fontFamily: "'JetBrains Mono', monospace", fontSize: 11, lineHeight: 1.6
            }}>
              {logs.length === 0 ? (
                <div style={{ color: 'var(--text-muted)', padding: 16, textAlign: 'center' }}>
                  No log entries yet. Logs will appear here as console.log/warn/error are called.
                </div>
              ) : (
                logs.map((entry, i) => (
                  <div key={i} style={{ display: 'flex', gap: 8, padding: '2px 4px', borderBottom: '1px solid rgba(42,49,66,0.3)' }}>
                    <span style={{ color: 'var(--text-muted)', flexShrink: 0 }}>{entry.time}</span>
                    <span style={{ color: logColors[entry.level], flexShrink: 0, width: 40, textTransform: 'uppercase', fontWeight: 600, fontSize: 10 }}>{entry.level}</span>
                    <span style={{ color: logColors[entry.level], whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>{entry.msg}</span>
                  </div>
                ))
              )}
              <div ref={logsEndRef} />
            </div>
          </div>
        </div>
      );

      // ─── Main Render ──────────────────────────────
      return (
        <div>
          {/* Navigation */}
          <nav className="top-nav">
            <div className="nav-logo">
              <div className="logo-icon">O</div>
              <span>ORB Trading</span>
              <span style={{ fontSize: 10, color: 'var(--text-muted)', fontWeight: 400, fontFamily: "'JetBrains Mono', monospace" }}>v{APP_VERSION}</span>
            </div>
            <div className="nav-tabs">
              {[
                { id: 'overview', label: 'Overview' },
                { id: 'sentiment', label: 'Sentiment' },
                { id: 'backtest', label: 'Backtest' },
                { id: 'strategy', label: 'Strategy' },
                { id: 'learn', label: 'Learn' },
                { id: 'admin', label: 'Admin' },
              ].map(tab => (
                <button key={tab.id}
                  className={`nav-tab ${activeTab === tab.id ? 'active' : ''}`}
                  onClick={() => setActiveTab(tab.id)}>
                  {tab.label}
                </button>
              ))}
            </div>
            <div className="nav-status">
              <button
                className="cache-clear-btn"
                onClick={async () => {
                  setCacheStatus('Clearing...');
                  try {
                    const keys = await caches.keys();
                    await Promise.all(keys.map(k => caches.delete(k)));
                    if ('serviceWorker' in navigator) {
                      const reg = await navigator.serviceWorker.getRegistration();
                      if (reg) await reg.unregister();
                    }
                    setCacheStatus(`Cleared ${keys.length} cache(s). Reload to re-register.`);
                    location.reload();
                  } catch (e) {
                    setCacheStatus('Error: ' + e.message);
                  }
                }}
                title="Clear caches, unregister service worker, and reload"
              >
                Clear Cache
              </button>
              <div className="market-status">
                <div className={`status-dot ${simRunning ? '' : 'closed'}`} />
                <span style={{ color: 'var(--text-muted)', fontSize: 12 }}>
                  {simRunning ? 'SIM LIVE' : 'SIM PAUSED'}
                </span>
              </div>
              <span className="mono" style={{ color: 'var(--text-muted)', fontSize: 12 }}>{today}</span>
            </div>
          </nav>

          <div className="app-container">
            {/* Ticker selector (hidden on overview) */}
            {activeTab !== 'overview' && activeTab !== 'admin' && (
              <div style={{ marginBottom: 16 }}>
                <div className="ticker-pills">
                  {ALL_TICKERS.map(t => (
                    <button key={t}
                      className={`ticker-pill ${selectedTicker === t ? 'active' : ''}`}
                      onClick={() => setSelectedTicker(t)}>
                      {t}
                    </button>
                  ))}
                </div>
              </div>
            )}

            {/* Tab content */}
            {activeTab === 'overview' && renderOverview()}
            {activeTab === 'sentiment' && renderSentiment()}
            {activeTab === 'backtest' && renderBacktest()}
            {activeTab === 'strategy' && renderStrategy()}
            {activeTab === 'learn' && renderLearn()}
            {activeTab === 'admin' && renderAdmin()}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('service-worker.js');
      });
    }
  </script>
</body>
</html>
